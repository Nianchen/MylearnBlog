(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{284:function(t,s,a){t.exports=a.p+"assets/img/image-20210820133728174.82cee6f7.png"},285:function(t,s,a){t.exports=a.p+"assets/img/UPcJwNrZz9hREbd.bd63ec8f.png"},286:function(t,s,a){t.exports=a.p+"assets/img/image-20210909193902821.6de55406.png"},287:function(t,s,a){t.exports=a.p+"assets/img/image-20210909194305714.ee4d8cb4.png"},288:function(t,s,a){t.exports=a.p+"assets/img/image-20210910152623549.a3da0b7b.png"},289:function(t,s,a){t.exports=a.p+"assets/img/KkZOFGP9t7UMCVr.d0849ac6.png"},290:function(t,s,a){t.exports=a.p+"assets/img/sgqeoOWyrTGjSRK.c49edb2d.png"},302:function(t,s,a){"use strict";a.r(s);var r=a(13),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"从输入url到页面展示-都发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到页面展示-都发生了什么"}},[t._v("#")]),t._v(" 从输入URL到页面展示 都发生了什么？？？")]),t._v(" "),s("p",[t._v("大概的流程图如下")]),t._v(" "),s("p",[s("img",{attrs:{src:a(284),alt:"image-20210820133728174"}})]),t._v(" "),s("p",[t._v("我们也需要知道浏览器各个进程之间都是负责哪方面工作的")]),t._v(" "),s("p",[s("img",{attrs:{src:a(285),alt:"image-20210907110700156"}})]),t._v(" "),s("p",[t._v("由于避免单进程一个进程的出错或者堵塞，导致整个网页无法正常打开，如今的浏览器虽然依旧采用单线程语言，但同时维护了多个进程 用来分别处理不同的事情,但是这样虽然解决了 网页崩溃问题 但同时也带来了更高的内存消耗")]),t._v(" "),s("h3",{attrs:{id:"处理链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#处理链接"}},[t._v("#")]),t._v(" 处理链接")]),t._v(" "),s("p",[t._v("首先用户在地址栏输入要访问的地址 ，然后浏览器会判断 他是关键字还是url连接。\nurl全程是统一资源定位符他是用来定位互联网中的资源的。\n处理完对应的url链接后，浏览器开始发送请求，这个请求一般是先访问本地缓存的，如果本地存在这个网页资源 那么就可以直接渲染 ，这也是为何浏览器第二次打开一个网页的速度一般比第一次快的原因")]),t._v(" "),s("h3",{attrs:{id:"发送请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发送请求"}},[t._v("#")]),t._v(" 发送请求")]),t._v(" "),s("p",[t._v("既然有请求那么相对应的也有响应， 如果响应头中的信息显示这个网页的资源需要重定向，不是你想要访问的网页 就会发生二次的重定向 然后再发起新的HTTP或者HTTPS请求，⼀切⼜重头开始了。\n响应头中最重要的信息是你访问网页的类型 Content-Type比如返回的是一个下载还是 页面 还是资源文件\n如果一切都正常，那么就会正常的进入渲染进程，一般同一站点的渲染由相同的进程进行渲染  即 相同协议和相同根目录的网站 一般用相同的进程去渲染，在这里类似于网站的同源策略")]),t._v(" "),s("h3",{attrs:{id:"提交文档阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#提交文档阶段"}},[t._v("#")]),t._v(" 提交文档阶段")]),t._v(" "),s("p",[t._v("渲染进程准备好之后，还不能⽴即进⼊⽂档解析状态。\n因为此时的⽂档数据还在⽹络进程中，并没有提交给渲染进程，所以下⼀步就进⼊了提交⽂档阶段。\n提交文档 是浏览器进程向渲染进程发出的 ，渲染进程接受到以后开始与网络数据建立连接然后等待数据，传输完成后渲染进程回复给浏览器进程一个完成的信号，然后浏览器首先更新一部分网站信息，比如显示地址栏，图标，前后退状态等等")]),t._v(" "),s("h3",{attrs:{id:"渲染阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染阶段"}},[t._v("#")]),t._v(" 渲染阶段")]),t._v(" "),s("p",[t._v("然后才是真正的进入了渲染阶段，浏览器的渲染是很复杂的一个阶段\n因为一个页面不仅有h5语言 还有css 还有js等多种语言浏览器需要分别识别并处理每一种语言\n这整个过程是一个"),s("strong",[t._v("线性流水线的过程")]),t._v("由多个子阶段组成"),s("br"),t._v("\n每个阶段都有一定输入的内容 ，也有处理过程，当然也有最终的输出内容。\n具体流程分为："),s("strong",[t._v("构建DOM树、样式计算、布局阶段、分 层、绘制、分块、光栅化和合成")]),t._v("\n按照时间顺序这几个阶段 依次进行")]),t._v(" "),s("h5",{attrs:{id:"_1-构建dom树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-构建dom树"}},[t._v("#")]),t._v(" 1.构建Dom树")]),t._v(" "),s("p",[t._v("因为浏览器无法直接识别H5语言  需要将 H5转化为Dom树供浏览器使用，就需要对页面中的HTML标签进行识别并生成dom树，dom树上包含了每一个元素的嵌套关系，也就是保存了父子元素之间的关系。但是dom树只处理了基本的标签元素，元素身上的样式并没有加载。")]),t._v(" "),s("h5",{attrs:{id:"_2-构建样式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-构建样式"}},[t._v("#")]),t._v(" 2.构建样式")]),t._v(" "),s("p",[t._v("我们就需要加载对应的css，一般有三种不同的引进方式  link 内嵌 style标签。\n但是我们写的css并不是浏览器最终使用的标准值，浏览器需要把css转换成标准值比如rgb颜色替换16进制颜色。\n然后进行计算样式，元素会依次继承父类锁拥有的css属性，因为dom树已经保存了相对应的父子关系。\n当把所有的样式都转换为标准值后，开始计算可见dom元素的位置信息，也就是布局信息。")]),t._v(" "),s("h5",{attrs:{id:"_3-布局阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-布局阶段"}},[t._v("#")]),t._v(" 3.布局阶段")]),t._v(" "),s("p",[t._v("布局树 其实和dom树很相像 但是布局树里面都是可见元素，也就是如果你设置了displaynone在这个布局树中都不会出现，然后对这些元素添加一些，定位相关的布局计算")]),t._v(" "),s("h5",{attrs:{id:"_4-分层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-分层"}},[t._v("#")]),t._v(" 4.分层")]),t._v(" "),s("p",[t._v("对于有一些地方的元素绘制就如同 Ps中的图层一样，明确定位属性的元素、定义透明属性的元素、使⽤CSS滤镜的元素等，都拥有层叠上下⽂属性。如果这一块级元素 有被隐藏的元素 那么他也会进一步分层。\n一般来说，布局树和分层树大部分是可以对应上的，如果一个元素没有自己的图层，那么他就会使用父元素的图层")]),t._v(" "),s("h5",{attrs:{id:"_5-光栅化和合成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-光栅化和合成"}},[t._v("#")]),t._v(" 5 光栅化和合成")]),t._v(" "),s("p",[t._v("当图层最后的处理结果提交给合成线程的时候，就需要合成出来最终的页面显示了，这个显示出来的部分，就是浏览器的视口，视口并不是窗口，视口指的是可以正常显示页面内容的地方，视口一般小于整个页面的大小，所以在逐步渲染的过程中，浏览器会根据当前视口的位置以及大小，逐步的对页面进行分块渲染。而不是一股脑全部渲染\n"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210261928157.png",alt:"image-20221026192826038"}}),t._v("\n有了上⾯介绍渲染流⽔线的基础，我们再来看看三个和渲染流⽔线相关的概念⸺重排 重绘 合成\n重排：故名思意你通过js或者 css对元素的几何属性进行修改会导致整个布局发生变换也就发生了重新排列\n重绘：就是改变了一些 颜色等等 不影响基础布局的属性\n那如果你更改⼀个既不要布局也不要绘制的属性，会发⽣什么变化呢？渲染引擎将跳过布局和绘制，只执⾏后续的合成操作，我们把这个过程叫做"),s("strong",[t._v("合成")])]),t._v(" "),s("h2",{attrs:{id:"js中的变量提升"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js中的变量提升"}},[t._v("#")]),t._v(" JS中的变量提升")]),t._v(" "),s("p",[t._v("JS的运行机制是先编译，所以在编译阶段，所有的变量和函数都会被声明(前提是你这个变量或者元素是通过var关键字声明的)所以即使你再声明之前调用了函数或者变量，他也不会报错只是显示未定义，但是如果这个函数和变量本身就不存在的话 还是会报错")]),t._v(" "),s("h2",{attrs:{id:"js中的执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js中的执行上下文"}},[t._v("#")]),t._v(" JS中的执行上下文")]),t._v(" "),s("p",[t._v("这就提到了JS中另一个概念叫做全局执行上下文 和 函数执行上下文   在这个变量提升的过程 其实就是建立了代码的全局上下文 将所有变量和函数压入这个全局上下文中， 然后在未来调用某个函数的时候 在 全局上下文中创造出来函数上下文 用来 单独运行函数")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/09/09/h1CkcBDp7XEIWoQ.png",alt:"image-20210909101947291"}})]),t._v(" "),s("p",[t._v("一旦函数运行完毕 就会释放当前函数执行上下文也就是出栈，并且销毁开辟的储存空间。\n每个执行上下文对应的都有一个this 指向自身 但是如果 只是全局定义的函数 this会指向windows")]),t._v(" "),s("p",[s("img",{attrs:{src:a(286),alt:"image-20210909193902821"}})]),t._v(" "),s("p",[t._v("可以通过call方法改变this指向")]),t._v(" "),s("p",[s("img",{attrs:{src:a(287),alt:"image-20210909194305714"}})]),t._v(" "),s("p",[t._v("JS本身是一门动态 弱数据类型的语言，声明变量前不需要提前声明变量的类型 。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(288),alt:"image-20210910152623549"}})]),t._v(" "),s("p",[t._v("除了最后一个 Object对象其他的都是原始数据类型，只有最后一个是引用数据类型")]),t._v(" "),s("h2",{attrs:{id:"js的垃圾回收原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js的垃圾回收原理"}},[t._v("#")]),t._v(" JS的垃圾回收原理")]),t._v(" "),s("p",[t._v("JS不需要像C那样使用free手动的释放某些变量内存，浏览器内核维护了一个垃圾回收装置进行回收垃圾，比如当函数的执行上下文被回收的时候就会进行垃圾回收，但是这针对的是栈中存储的变量，我们知道引用数据类型实在堆中存储的，那如何解决堆中的数据呢，最后给出合理的理解应该是，如果代码或者内存中还有对这个变量的引用，那么这一块内存就不会被释放，但是一旦有一个引用就不会被回收，比如闭包的情况下，就不会释放。")]),t._v(" "),s("h2",{attrs:{id:"js的内存原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js的内存原理"}},[t._v("#")]),t._v(" JS的内存原理")]),t._v(" "),s("p",[t._v("​                                                                                  这是JS内部内存的分配情况")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210261941295.png",alt:"image-20221026194155240"}})]),t._v(" "),s("p",[t._v("栈空间：存储执行上下文，同样包括了不同执行上下文内部的变量\n堆空间：存储引用数据类型，然后让栈中的变量引用堆中的地址")]),t._v(" "),s("h2",{attrs:{id:"js是如何在浏览器中运行的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js是如何在浏览器中运行的"}},[t._v("#")]),t._v(" JS是如何在浏览器中运行的")]),t._v(" "),s("p",[t._v("首先js代码顺次先转换成token(不是http携带的token)一般指最小不可被分割词，然后解析这些token形成AST树，例如H5文件转成DOM树\n的过程也有AST树生成，然后根据AST树生成字节码，这里通过的是解释器，字节码其实是属于v8引擎的一些东西，他介于了机器码和AST树之间的一种状态，然后是执行代码，在执行的过程中，如果遇到一部分反复执行的代码会定量的保存 一部分字节码 ，后期多次调用的时候直接调用这个字节码进行运行 就要比重新开始要快很多。")]),t._v(" "),s("h2",{attrs:{id:"浏览器⻚面是由消息队列和事件循环系统来驱-动的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器⻚面是由消息队列和事件循环系统来驱-动的"}},[t._v("#")]),t._v(" 浏览器⻚⾯是由消息队列和事件循环系统来驱 动的")]),t._v(" "),s("p",[t._v("即eventloop事件循环机制")]),t._v(" "),s("p",[t._v("日常浏览网页的时候会有一系列操作导致网站进行某些改变 ，或者是发生某些事件，比如鼠标点击等等，所以我们有一个循环的进程用来处理这些操作。\n同时通过一个消息队列用来储存所有的操作这样就可以保证操作进行的先后没有问题，但是对于一些优先级较高的操作，比如改变某些 dom元素的属性 我们又为每个宏任务也就是大任务背景下 添加了一个微小的任务列表 用来储存哪些优先级比较高的任务  这样就不会导致优先级的问题了\n微任务的优先级大于宏任务，比如promise settimeout")]),t._v(" "),s("h2",{attrs:{id:"set-timeout是如何实现的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set-timeout是如何实现的"}},[t._v("#")]),t._v(" set-timeout是如何实现的？")]),t._v(" "),s("p",[t._v("在上文中我们了解到了v8引擎中的 消息队列 同样为了针对这种延时任务 引擎中内置了 另一个消息队列 单独的用来储存这些 需要回调的函数  每次执行之后就会在消息队列中重新添加 ，但是这种延时函数也有最低要求 比如说0ms 执行5次以上浏览器会认为，他阻塞了会将0ms---\x3e4ms 进行执行\n即使这样已经解决了顺序的问题 但是如果一个任务的执行时间太长 同样也会影响其他任务的执行\n因为设置延时的问题 用js写动画 不太提倡， 你可以利用css 或者浏览器的渲染去写动画，性能上要比js好很多")]),t._v(" "),s("h2",{attrs:{id:"js如何渲染dom树-构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js如何渲染dom树-构建"}},[t._v("#")]),t._v(" JS如何渲染dom树 构建")]),t._v(" "),s("p",[t._v("Dom树的构建是由一个解析器完成的，就是将原来的HTML文件 进行分解分解成最小的token ，然后进行解析成dom元素，当然这些token 与 H5自身语言相近 比如 "),s("code",[t._v("<div>")]),t._v("这些 就被成为 Strattag 也就是开始标签 相对应的每个标签也由相应的 endtag  而这两个标签中间的内容 就是对应的文本内容\n而浏览器自身维护了一个栈区区进行 一个个token 的解读然后将新元素压栈 解读完后 将这个栈顶弹出，这样可以进一步的维护父子元素的关系\n如果在解析 H5 文件的时候遇到了JS文件，就会暂停dom的生成以及渲染先引入JS文件\n由于  浏览器引擎  和 网络  之间有一个类似于管道的东西在传输信息你可以理解为 网络交给浏览器多少他就渲染多少，但是为了提高页面渲染速率浏览器引擎一般都会提前下载好页面中需要的 js文件来提高运行速度")]),t._v(" "),s("h2",{attrs:{id:"渐进式-web页面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渐进式-web页面"}},[t._v("#")]),t._v(" 渐进式+Web页面")]),t._v(" "),s("p",[t._v("Web操作 本地操作的区别遭遇过去依赖浏览器以及网络没有离线操作以及一级入口")]),t._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5CLenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210923152501164.png",alt:"image-20210923152501164"}})]),t._v(" "),s("p",[t._v("Server worker的存在 是为了 避免一部分JS占用时间过长  让这一部分 代码运行在核心渲染引擎之外由于此时还没有 构建Dom 树等操作 导致 无法进行dom元素操作只能操作一些不涉及dom元素的JS 代码 整个线程 存在于浏览器的生命周期 可以同时服务多个页面")]),t._v(" "),s("p",[s("img",{attrs:{src:a(289),alt:"image-20210923153022564"}})]),t._v(" "),s("h2",{attrs:{id:"安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安全"}},[t._v("#")]),t._v(" 安全")]),t._v(" "),s("p",[s("img",{attrs:{src:a(290),alt:"image-20210923153041982"}})])])}),[],!1,null,null,null);s.default=e.exports}}]);