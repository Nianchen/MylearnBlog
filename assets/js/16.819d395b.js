(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{307:function(t,a,v){"use strict";v.r(a);var _=v(13),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"基础篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础篇"}},[t._v("#")]),t._v(" 基础篇")]),t._v(" "),a("h3",{attrs:{id:"_1-1-tcp-ip网络模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-tcp-ip网络模型"}},[t._v("#")]),t._v(" 1.1 TCP/Ip网络模型")]),t._v(" "),a("p",[t._v("主要用于不同设备之间的通信，为了兼容更多的设备从而进一步协商出来的网络协议")]),t._v(" "),a("h4",{attrs:{id:"_1-应用层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-应用层"}},[t._v("#")]),t._v(" 1.应用层")]),t._v(" "),a("p",[t._v("正常用户所能接触到的层次，也就是app对应的层次。")]),t._v(" "),a("h4",{attrs:{id:"_2-传输层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-传输层"}},[t._v("#")]),t._v(" 2.传输层")]),t._v(" "),a("p",[t._v("应用层之间的数据传输，就需要传输层进行 传输数据")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210241512271.png",alt:"image-20221024151247157"}})]),t._v(" "),a("p",[t._v("传输层对应的两个不同的协议就是TCP和UDP，两者最大的不同就是TCP具有一个有效的链接，更加可靠，能保证数据的完整性和传输的准确性")]),t._v(" "),a("h4",{attrs:{id:"_3-网络层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-网络层"}},[t._v("#")]),t._v(" 3.网络层")]),t._v(" "),a("p",[t._v("网络层就涉及到不同设备之间的传输了，应用层只是在同一设备的不同app之间的传输\n在网络层中最常见的协议就是ip协议，ip协议与传输层的数据，IP包的头部一同组成ip报文，如果这个报文超过了MTU的临界值就会把这个报文进行分片，也就是分段传输")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210241518273.png",alt:"image-20221024151835187"}})]),t._v(" "),a("p",[t._v("网络层既然需要再网络上进行传输数据，那么就应该知道我们传输数据的目的地，也就是如何找到对方，IP协议中对应的方法就是使用IP地址，IP协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘")]),t._v(" "),a("h4",{attrs:{id:"数据链路层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层"}},[t._v("#")]),t._v(" 数据链路层")]),t._v(" "),a("p",[t._v("之前针对的网络是在同一路由环境下的网络情况，如果我们需要进一步的向不属于自己网络的地方发送东西，一般就需要")]),t._v(" "),a("p",[t._v("//暂时不写了")]),t._v(" "),a("h2",{attrs:{id:"http篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http篇"}},[t._v("#")]),t._v(" HTTP篇")]),t._v(" "),a("h3",{attrs:{id:"什么是http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是http"}},[t._v("#")]),t._v(" 什么是HTTP")]),t._v(" "),a("p",[t._v("翻译过来是叫做超文本传输协议\n仔细拆分一下，就是三个部分 1.超文本2.传输3.协议\n解释下什么叫做超文本吧，超文本指的是 文字 图片 视频 音频等超级文本数据\n把这个称谓再进一步的扩大一下就是\n"),a("strong",[t._v("HTTP是一个在计算机世界两点之间传输文字 图片 视频 音频等 超文本数据的约定和规范")])]),t._v(" "),a("h3",{attrs:{id:"http状态码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" HTTP状态码")]),t._v(" "),a("p",[t._v("1xx：协议中间状态需要后续操作")]),t._v(" "),a("p",[t._v("2xx：成功 比如200返回成功并正确处理请求")]),t._v(" "),a("p",[t._v("3xx：资源重定向")]),t._v(" "),a("p",[t._v("4xx：客户端请求出错，服务器没有办法处理这个请求")]),t._v(" "),a("p",[t._v("5xx：服务器挂了")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210241536517.png",alt:"image-20221024153654408"}})]),t._v(" "),a("h3",{attrs:{id:"常见的字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的字段"}},[t._v("#")]),t._v(" 常见的字段")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Host")]),t._v(" "),a("th",[t._v("客户端发送请求的时候携带上Host字段就可以明确知道我需要访问哪一个服务器")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Contet-length")]),t._v(" "),a("td",[t._v("表示返回数据的时候，本次返回数据的长度(字节)")])]),t._v(" "),a("tr",[a("td",[t._v("Connection")]),t._v(" "),a("td",[t._v("要求服务器使用TCP持久化链接来保持链接复用，因为http1本身就是持久化链接所以这个给值默认的是keep-alive")])]),t._v(" "),a("tr",[a("td",[t._v("Content-type")]),t._v(" "),a("td",[t._v("告诉客户端，本次数据是什么格式 例如 utf-8")])]),t._v(" "),a("tr",[a("td",[t._v("Content-Encoding")]),t._v(" "),a("td",[t._v("字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式")])])])]),t._v(" "),a("h3",{attrs:{id:"get与post"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get与post"}},[t._v("#")]),t._v(" Get与Post")]),t._v(" "),a("p",[t._v("最大区别是Get只能向服务器请求资源,但是Post可以向服务器提交资源,所以一般表单等收集信息的使用的都是Post方式,因为不涉及提交数据所以Get方法一般都是安全的,他不会造成服务器数据的损伤,但是Post可以改变服务器的数据,也可以携带一些不安全的数据,所以Post本身不安全")]),t._v(" "),a("h3",{attrs:{id:"http1-1特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-1特性"}},[t._v("#")]),t._v(" Http1.1特性")]),t._v(" "),a("h4",{attrs:{id:"优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[t._v("#")]),t._v(" 优缺点")]),t._v(" "),a("ol",[a("li",[t._v("简单,报文只有header+body 且header中也是一个个key-value字段,很好识别和学习")]),t._v(" "),a("li",[t._v("灵活,http协议的请求方法都允许开发人员自定义组成,灵活性比较高")]),t._v(" "),a("li",[a("strong",[t._v("跨平台")]),t._v("的优越性。基本上所有平台都可以使用http协议进行通信")]),t._v(" "),a("li",[t._v("不安全!自身是无状态的,无状态就导致了可能在绝大多数的情况下都需要验证身份的合法性")]),t._v(" "),a("li",[t._v("全程明文传输 ,一旦不加密被抓包就会暴露所有的数据,这个数据也可以被劫持方随意修改,安全性比较差")])]),t._v(" "),a("h4",{attrs:{id:"性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),a("p",[t._v("在早期的开发中,每一次的请求都需要简历TCP链接.我们知道TCP需要三次握手才能建立链接,而且如果一方不主动断开连接.这个链接就会一直存在,如果在一个串行的请求过程中就会导致这个建立链接的过程进行很多次的重复,增加了很多无畏的服务器开销,后来进一步使用了管道传输的方式,在一个Tcp握手中我们可以发起多个http请求,不需要等待前一个返回就直接发送下一个这样就可以i减少整体的响应时间")]),t._v(" "),a("p",[t._v("队头堵塞的问题 既然可以串行的进行发送多个请求,那么只要前面的请求堵塞,就会导致整个队列的阻塞")]),t._v(" "),a("h3",{attrs:{id:"https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),a("h4",{attrs:{id:"http与https的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http与https的区别"}},[t._v("#")]),t._v(" HTTP与HTTPS的区别")]),t._v(" "),a("ol",[a("li",[t._v("HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在")])]),t._v(" "),a("p",[t._v("TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之")])]),t._v(" "),a("p",[t._v("后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("p",[t._v("HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。")])]),t._v(" "),a("li",[a("p",[t._v("HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。")])]),t._v(" "),a("li",[a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210271930113.png",alt:"image-20221024191605953"}})])])]),t._v(" "),a("h4",{attrs:{id:"安全性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全性"}},[t._v("#")]),t._v(" 安全性")]),t._v(" "),a("p",[t._v("HTTPS采用混合加密,以及对body内数据的摘要加密,还有数字证书认证等多种方法保证了安全性")]),t._v(" "),a("p",[t._v("我们已知在HTTP与TCP之间加入了TLS协议，来解决HTTP存在的安全性问题，TLS只要是通过三个手段进行的，1.信息加密 2.校验机制 3.身份证书 TLS本身实在TCP已经建立链接后发生的，需要2个RTT时延，但是针对不同的加密手段，也就是密钥交换算法，这个具体流程是有部分的区别的")]),t._v(" "),a("h4",{attrs:{id:"http-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[t._v("#")]),t._v(" "),a("strong",[t._v("HTTP/2")])]),t._v(" "),a("p",[t._v("其实主要针对的还是http1在使用中的不足之处，如下")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210271934262.png",alt:"image-20221027193402201"}})]),t._v(" "),a("p",[t._v("HTTP/2在语法层面上可以完全兼容HTTP/1的语法，所以兼容性很高，而且只是服务器协议的更换，用户自身并没有很明显的意识")]),t._v(" "),a("ol",[a("li",[t._v("更改了头部信息的压缩方式，使用了HPACK算法在内部维护了一张静态表去对应请求的头信息，还是自身key-value的形式但是又使用了huffman编码，就让整体的大小得到很大的压缩，但是静态表的种类是有限的，有一些并没有在静态表中的信息，就需要额外维护一个动态表，进行动态更新对应的头信息，但是如果头信息过于复杂，那么这个开辟的动态表也就十分的占用空间")]),t._v(" "),a("li",[t._v("二进制帧，相比于HTTP/1的纯文本传输方式，HTTP/2把这个文本文件转化成了二进制帧的形式，让解析更加高效，这个帧分为了数据帧和控制帧，数据帧李放的是HTTP头 包还有优先级，控制帧主要是链接相关的东西")]),t._v(" "),a("li",[t._v("并发传输， 既然还是基于TCP链接，那么这个建立链接的过程就不可能忽略，HTTP2通过Stream的涉及，让多个Stream复用一个TCP链接，在一个TCP链接中可能包含了多个请求。达到了并发的效果")]),t._v(" "),a("li",[t._v("也就是改善了原有传统的 请求----应答这个模式,服务器主动向客户端推送JS CSS等一些静态文件,这样能减少延时的等待时间")])]),t._v(" "),a("p",[t._v("但是既然还是采用了TCP链接的问题，那么都绕不过数据完整性，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区⾥的数据返回给 HTTP 应⽤，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区⾥，只有等到这 1 个字节数据到达时，HTTP/2应⽤层才能从内核中拿到数据，这就是HTTP/2 队头阻塞问题。")]),t._v(" "),a("h4",{attrs:{id:"http-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-3"}},[t._v("#")]),t._v(" HTTP/3")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210271954285.png",alt:"image-20221027195447215"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210272006741.png",alt:"image-20221027200652689"}})]),t._v(" "),a("h2",{attrs:{id:"tcp篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp篇"}},[t._v("#")]),t._v(" TCP篇")]),t._v(" "),a("h4",{attrs:{id:"tcp头部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp头部"}},[t._v("#")]),t._v(" TCP头部")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210272009290.png",alt:"image-20221027200937229"}})])])}),[],!1,null,null,null);a.default=s.exports}}]);