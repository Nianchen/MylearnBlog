(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{309:function(t,a,_){"use strict";_.r(a);var v=_(13),s=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"基础篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础篇"}},[t._v("#")]),t._v(" 基础篇")]),t._v(" "),a("h3",{attrs:{id:"_1-1-tcp-ip网络模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-tcp-ip网络模型"}},[t._v("#")]),t._v(" 1.1 TCP/Ip网络模型")]),t._v(" "),a("p",[t._v("主要用于不同设备之间的通信，为了兼容更多的设备从而进一步协商出来的网络协议")]),t._v(" "),a("h4",{attrs:{id:"_1-应用层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-应用层"}},[t._v("#")]),t._v(" 1.应用层")]),t._v(" "),a("p",[t._v("正常用户所能接触到的层次，也就是app对应的层次。")]),t._v(" "),a("h4",{attrs:{id:"_2-传输层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-传输层"}},[t._v("#")]),t._v(" 2.传输层")]),t._v(" "),a("p",[t._v("应用层之间的数据传输，就需要传输层进行 传输数据")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210241512271.png",alt:"image-20221024151247157"}})]),t._v(" "),a("p",[t._v("传输层对应的两个不同的协议就是TCP和UDP，两者最大的不同就是TCP具有一个有效的链接，更加可靠，能保证数据的完整性和传输的准确性")]),t._v(" "),a("h4",{attrs:{id:"_3-网络层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-网络层"}},[t._v("#")]),t._v(" 3.网络层")]),t._v(" "),a("p",[t._v("网络层就涉及到不同设备之间的传输了，应用层只是在同一设备的不同app之间的传输\n在网络层中最常见的协议就是ip协议，ip协议与传输层的数据，IP包的头部一同组成ip报文，如果这个报文超过了MTU的临界值就会把这个报文进行分片，也就是分段传输")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210241518273.png",alt:"image-20221024151835187"}})]),t._v(" "),a("p",[t._v("网络层既然需要再网络上进行传输数据，那么就应该知道我们传输数据的目的地，也就是如何找到对方，IP协议中对应的方法就是使用IP地址，IP协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘")]),t._v(" "),a("h4",{attrs:{id:"数据链路层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层"}},[t._v("#")]),t._v(" 数据链路层")]),t._v(" "),a("p",[t._v("之前针对的网络是在同一路由环境下的网络情况，如果我们需要进一步的向不属于自己网络的地方发送东西，一般就需要")]),t._v(" "),a("p",[t._v("//暂时不写了")]),t._v(" "),a("h2",{attrs:{id:"http篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http篇"}},[t._v("#")]),t._v(" HTTP篇")]),t._v(" "),a("h3",{attrs:{id:"什么是http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是http"}},[t._v("#")]),t._v(" 什么是HTTP")]),t._v(" "),a("p",[t._v("翻译过来是叫做超文本传输协议\n仔细拆分一下，就是三个部分 1.超文本2.传输3.协议\n解释下什么叫做超文本吧，超文本指的是 文字 图片 视频 音频等超级文本数据\n把这个称谓再进一步的扩大一下就是\n"),a("strong",[t._v("HTTP是一个在计算机世界两点之间传输文字 图片 视频 音频等 超文本数据的约定和规范")])]),t._v(" "),a("h3",{attrs:{id:"http状态码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" HTTP状态码")]),t._v(" "),a("p",[t._v("1xx：协议中间状态需要后续操作")]),t._v(" "),a("p",[t._v("2xx：成功 比如200返回成功并正确处理请求")]),t._v(" "),a("p",[t._v("3xx：资源重定向")]),t._v(" "),a("p",[t._v("4xx：客户端请求出错，服务器没有办法处理这个请求")]),t._v(" "),a("p",[t._v("5xx：服务器挂了")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210241536517.png",alt:"image-20221024153654408"}})]),t._v(" "),a("h3",{attrs:{id:"常见的字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的字段"}},[t._v("#")]),t._v(" 常见的字段")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Host")]),t._v(" "),a("th",[t._v("客户端发送请求的时候携带上Host字段就可以明确知道我需要访问哪一个服务器")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Contet-length")]),t._v(" "),a("td",[t._v("表示返回数据的时候，本次返回数据的长度(字节)")])]),t._v(" "),a("tr",[a("td",[t._v("Connection")]),t._v(" "),a("td",[t._v("要求服务器使用TCP持久化链接来保持链接复用，因为http1本身就是持久化链接所以这个给值默认的是keep-alive")])]),t._v(" "),a("tr",[a("td",[t._v("Content-type")]),t._v(" "),a("td",[t._v("告诉客户端，本次数据是什么格式 例如 utf-8")])]),t._v(" "),a("tr",[a("td",[t._v("Content-Encoding")]),t._v(" "),a("td",[t._v("字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式")])])])]),t._v(" "),a("h3",{attrs:{id:"get与post"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get与post"}},[t._v("#")]),t._v(" Get与Post")]),t._v(" "),a("p",[t._v("最大区别是Get只能向服务器请求资源,但是Post可以向服务器提交资源,所以一般表单等收集信息的使用的都是Post方式,因为不涉及提交数据所以Get方法一般都是安全的,他不会造成服务器数据的损伤,但是Post可以改变服务器的数据,也可以携带一些不安全的数据,所以Post本身不安全")]),t._v(" "),a("h3",{attrs:{id:"http1-1特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-1特性"}},[t._v("#")]),t._v(" Http1.1特性")]),t._v(" "),a("h4",{attrs:{id:"优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[t._v("#")]),t._v(" 优缺点")]),t._v(" "),a("ol",[a("li",[t._v("简单,报文只有header+body 且header中也是一个个key-value字段,很好识别和学习")]),t._v(" "),a("li",[t._v("灵活,http协议的请求方法都允许开发人员自定义组成,灵活性比较高")]),t._v(" "),a("li",[a("strong",[t._v("跨平台")]),t._v("的优越性。基本上所有平台都可以使用http协议进行通信")]),t._v(" "),a("li",[t._v("不安全!自身是无状态的,无状态就导致了可能在绝大多数的情况下都需要验证身份的合法性")]),t._v(" "),a("li",[t._v("全程明文传输 ,一旦不加密被抓包就会暴露所有的数据,这个数据也可以被劫持方随意修改,安全性比较差")])]),t._v(" "),a("h4",{attrs:{id:"性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),a("p",[t._v("在早期的开发中,每一次的请求都需要简历TCP链接.我们知道TCP需要三次握手才能建立链接,而且如果一方不主动断开连接.这个链接就会一直存在,如果在一个串行的请求过程中就会导致这个建立链接的过程进行很多次的重复,增加了很多无畏的服务器开销,后来进一步使用了管道传输的方式,在一个Tcp握手中我们可以发起多个http请求,不需要等待前一个返回就直接发送下一个这样就可以i减少整体的响应时间")]),t._v(" "),a("p",[t._v("队头堵塞的问题 既然可以串行的进行发送多个请求,那么只要前面的请求堵塞,就会导致整个队列的阻塞")]),t._v(" "),a("h3",{attrs:{id:"https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),a("h4",{attrs:{id:"http与https的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http与https的区别"}},[t._v("#")]),t._v(" HTTP与HTTPS的区别")]),t._v(" "),a("ol",[a("li",[t._v("HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在")])]),t._v(" "),a("p",[t._v("TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之")])]),t._v(" "),a("p",[t._v("后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("p",[t._v("HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。")])]),t._v(" "),a("li",[a("p",[t._v("HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。")])]),t._v(" "),a("li",[a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210271930113.png",alt:"image-20221024191605953"}})])])]),t._v(" "),a("h4",{attrs:{id:"安全性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全性"}},[t._v("#")]),t._v(" 安全性")]),t._v(" "),a("p",[t._v("HTTPS采用混合加密,以及对body内数据的摘要加密,还有数字证书认证等多种方法保证了安全性")]),t._v(" "),a("p",[t._v("我们已知在HTTP与TCP之间加入了TLS协议，来解决HTTP存在的安全性问题，TLS只要是通过三个手段进行的，1.信息加密 2.校验机制 3.身份证书 TLS本身实在TCP已经建立链接后发生的，需要2个RTT时延，但是针对不同的加密手段，也就是密钥交换算法，这个具体流程是有部分的区别的")]),t._v(" "),a("h4",{attrs:{id:"http-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[t._v("#")]),t._v(" "),a("strong",[t._v("HTTP/2")])]),t._v(" "),a("p",[t._v("其实主要针对的还是http1在使用中的不足之处，如下")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210271934262.png",alt:"image-20221027193402201"}})]),t._v(" "),a("p",[t._v("HTTP/2在语法层面上可以完全兼容HTTP/1的语法，所以兼容性很高，而且只是服务器协议的更换，用户自身并没有很明显的意识")]),t._v(" "),a("ol",[a("li",[t._v("更改了头部信息的压缩方式，使用了HPACK算法在内部维护了一张静态表去对应请求的头信息，还是自身key-value的形式但是又使用了huffman编码，就让整体的大小得到很大的压缩，但是静态表的种类是有限的，有一些并没有在静态表中的信息，就需要额外维护一个动态表，进行动态更新对应的头信息，但是如果头信息过于复杂，那么这个开辟的动态表也就十分的占用空间")]),t._v(" "),a("li",[t._v("二进制帧，相比于HTTP/1的纯文本传输方式，HTTP/2把这个文本文件转化成了二进制帧的形式，让解析更加高效，这个帧分为了数据帧和控制帧，数据帧李放的是HTTP头 包还有优先级，控制帧主要是链接相关的东西")]),t._v(" "),a("li",[t._v("并发传输， 既然还是基于TCP链接，那么这个建立链接的过程就不可能忽略，HTTP2通过Stream的涉及，让多个Stream复用一个TCP链接，在一个TCP链接中可能包含了多个请求。达到了并发的效果")]),t._v(" "),a("li",[t._v("也就是改善了原有传统的 请求----应答这个模式,服务器主动向客户端推送JS CSS等一些静态文件,这样能减少延时的等待时间")])]),t._v(" "),a("p",[t._v("但是既然还是采用了TCP链接的问题，那么都绕不过数据完整性，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区⾥的数据返回给 HTTP 应⽤，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区⾥，只有等到这 1 个字节数据到达时，HTTP/2应⽤层才能从内核中拿到数据，这就是HTTP/2 队头阻塞问题。")]),t._v(" "),a("h4",{attrs:{id:"http-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-3"}},[t._v("#")]),t._v(" HTTP/3")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210271954285.png",alt:"image-20221027195447215"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210272006741.png",alt:"image-20221027200652689"}})]),t._v(" "),a("h2",{attrs:{id:"tcp篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp篇"}},[t._v("#")]),t._v(" TCP篇")]),t._v(" "),a("h3",{attrs:{id:"tcp头部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp头部"}},[t._v("#")]),t._v(" TCP头部")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210272009290.png",alt:"image-20221027200937229"}})]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("端口号")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("保证在计算机网络中找到目标ip与端口保证数据传输")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("序列号")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("建立链接时生成用来保证多个不同的请求之间是有序的，通过SYN包传输给端主机")])]),t._v(" "),a("tr",[a("td",[t._v("确认应答号")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("指下一次收到的回复包中期望的序列号，来保证数据已经传输完成")])])])]),t._v(" "),a("h3",{attrs:{id:"tcp控制位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp控制位"}},[t._v("#")]),t._v(" TCP控制位")]),t._v(" "),a("ul",[a("li",[t._v("ACK：该位为 1 时，表示确认应答")]),t._v(" "),a("li",[t._v("RST：该为为 1 时，表示这个链接应该强制断开")]),t._v(" "),a("li",[t._v("SYN：该包为 1 时，表示希望建立链接，发出建立链接的信号")]),t._v(" "),a("li",[t._v("FIN：该包为 1 时，表示希望断开链接，在此之后没有了新的数据进行发送")])]),t._v(" "),a("h3",{attrs:{id:"为什么tcp要在传输层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么tcp要在传输层"}},[t._v("#")]),t._v(" 为什么TCP要在传输层")]),t._v(" "),a("p",[t._v("因为网络层的IP协议，只能帮助你找到目标主机，自身并不负责交互数据，也不能保证数据的完整性")]),t._v(" "),a("h3",{attrs:{id:"如何确定一个唯一的tcp链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何确定一个唯一的tcp链接"}},[t._v("#")]),t._v(" 如何确定一个唯一的TCP链接")]),t._v(" "),a("p",[t._v("首先我们要知道TCP通过四元组建立链接，这个四元组分别指，源地址，源端口，目标地址，目标端口，可以理解为从一个电脑的某个软件定向到另一个电脑上的软件")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210311836745.png",alt:"image-20221031183646684"}})]),t._v(" "),a("h3",{attrs:{id:"tcp连接数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接数"}},[t._v("#")]),t._v(" TCP连接数")]),t._v(" "),a("p",[t._v("TCP连接数是由端口决定的，目标服务器上开放的端口数就是可以建立的TCP数量，但是一般服务器接受不了这么高的并发，都会限制服务端的TCP链接数量")]),t._v(" "),a("h3",{attrs:{id:"udp与tcp的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#udp与tcp的区别"}},[t._v("#")]),t._v(" UDP与TCP的区别")]),t._v(" "),a("ul",[a("li",[t._v("相对比与TCP复杂的头部信息，UDP的头部信息非常简洁，只有8个字节，在系统中的开销比较小。但是TCP的头就比较庞大开销大")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210311840543.png",alt:"image-20221031184027454"}})]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("⽬标和源端⼝")]),t._v(" "),a("th",[t._v("主要是告诉 UDP 协议应该把报⽂发给哪个进程")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("包⻓度")]),t._v(" "),a("td",[t._v("该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。")])]),t._v(" "),a("tr",[a("td",[t._v("校验和")]),t._v(" "),a("td",[t._v("校验和是为了提供可靠的 UDP ⾸部和数据⽽设计")])])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("UDP利用IP协议达成无连接的通信，在传输数据前不需要建立连接")])]),t._v(" "),a("li",[a("p",[t._v("TCP只能点对点的传输信息，但是UDP可以做到点对面，即一对多的交互通信")])]),t._v(" "),a("li",[a("p",[t._v("TCP对于数据而言非常严格，数据可以⽆差错、不丢失、不重复、按需到达")])]),t._v(" "),a("li",[a("p",[t._v("UDP尽力进行交付数据，但是不去关注数据是否正常送达")])]),t._v(" "),a("li",[a("p",[t._v("TCP 有拥塞控制和流量控制机制，保证数据传输的安全性，UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率")])]),t._v(" "),a("li",[a("p",[t._v("TCP基于流式传输，UDP基于发包传输")])]),t._v(" "),a("li",[a("p",[t._v("TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。")])]),t._v(" "),a("li",[a("p",[t._v("UDP 的数据⼤⼩如果⼤于 MTU(传输中最大的传输包)⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着")]),t._v(" "),a("p",[t._v("再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。")])])]),t._v(" "),a("h3",{attrs:{id:"tcp的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp的应用场景"}},[t._v("#")]),t._v(" TCP的应用场景")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210311848557.png",alt:"image-20221031184807502"}})]),t._v(" "),a("h3",{attrs:{id:"tcp的链接过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp的链接过程"}},[t._v("#")]),t._v(" TCP的链接过程")]),t._v(" "),a("p",[t._v("提起tcp的链接过程，大多数人第一印象肯定是三次握手，但是在这个三次握手中具体发生了什么，其实很多人也不太清楚。\n具体 流程如下")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210311852736.png",alt:"image-20221031185227654"}})]),t._v(" "),a("ul",[a("li",[t._v("1.准备阶段，客户端和服务器都没有建立链接，都处于closed状态，服务器端则处于listen状态监听某个端口")]),t._v(" "),a("li",[t._v("2.客户端随机初始化序列号(client_isn)，也就是tcp头部携带的序列号，然后把SYN的控制位更改为 1 意思是客户端想要建立链接，然后把生成的SYN报文送给服务器后，客户端处于 SYN-SENT状态")]),t._v(" "),a("li",[t._v("3.服务端收到SYN报文后，先跟客户端一样，随机化自己的序号(server_isn)，然后把收到的client_isn + 1，然后把控制位的SYN与ACK全部更改为 1 ，意思是服务端同意建立链接，然后发送SYN+ACK报文，服务端处于SYN-RCVD状态")]),t._v(" "),a("li",[t._v("4.客户端收到服务器发过来的同意报文后，也重新把server_isn + 1 后将ACK更改为1，重新发送给服务端ACK报文，从这次链接后才能携带客户端需要发送的数据，之后进入ESTABLISHED")]),t._v(" "),a("li",[t._v("5.服务器收到最后一个ACK报文后也进入了ESTABLISHED状态")])]),t._v(" "),a("h3",{attrs:{id:"tcp为什么选择三次握手而不是两次或者四次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp为什么选择三次握手而不是两次或者四次"}},[t._v("#")]),t._v(" TCP为什么选择三次握手而不是两次或者四次")]),t._v(" "),a("h4",{attrs:{id:"一-避免历史链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-避免历史链接"}},[t._v("#")]),t._v(" 一，避免历史链接")]),t._v(" "),a("p",[t._v("由于实际的网络空间并不是理想化的，存在明显的网络延迟，如果新发出的请求被延迟到达了，那么老请求的返回包就会导致链接出错TCP 使⽤三次握⼿建⽴连接的最主要原因是"),a("strong",[t._v("防⽌历史连接初始化了连接。")])]),t._v(" "),a("h4",{attrs:{id:"二-同步双方初始序列号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-同步双方初始序列号"}},[t._v("#")]),t._v(" 二，同步双⽅初始序列号")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210311914528.png",alt:"image-20221031191423481"}})]),t._v(" "),a("h4",{attrs:{id:"三-避免资源浪费"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-避免资源浪费"}},[t._v("#")]),t._v(" 三，避免资源浪费")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210311915959.png",alt:"image-20221031191530901"}})]),t._v(" "),a("h3",{attrs:{id:"客户端与服务端如何初始化序列号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端与服务端如何初始化序列号"}},[t._v("#")]),t._v(" 客户端与服务端如何初始化序列号")]),t._v(" "),a("p",[t._v("基于时钟生成，每4ms + 1 最终再经过hash得到最终结果 ISN = M(时钟) + F(hash)")]),t._v(" "),a("h3",{attrs:{id:"为什么tcp需要mss"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么tcp需要mss"}},[t._v("#")]),t._v(" 为什么TCP需要MSS")]),t._v(" "),a("p",[t._v("MSS：指除去 IP 和 TCP 头部，剩下的空间能容纳TCP数据的最大长度\nMTU：则是携带上 IP 和 TCP头部。\nMSS = MTU - IP - TCP")]),t._v(" "),a("p",[t._v("经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后，"),a("strong",[t._v("进⾏重发时也是以")]),t._v(" "),a("strong",[t._v("MSS")]),t._v(" "),a("strong",[t._v("为单位")]),t._v("，⽽不⽤᯿传所有的分⽚，⼤⼤增加了重传的效率")]),t._v(" "),a("h3",{attrs:{id:"tcp的断开过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp的断开过程"}},[t._v("#")]),t._v(" TCP的断开过程")]),t._v(" "),a("p",[t._v("对应建立链接的三次握手，断开整个过程叫做四次挥手，具体流程如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210311935817.png",alt:"image-20221031193536741"}})]),t._v(" "),a("ol",[a("li",[t._v("我们这里假设客户端断开链接，发送一个FIN标志为为1的报文，意思是需要断开链接后，进入FIN_WAIT_1状态")]),t._v(" "),a("li",[t._v("服务器收到FIN报文后，回复ACK报文后，进入CLOSEN_WAIT等待关闭状态")]),t._v(" "),a("li",[t._v("客户端收到服务器的同意断开的报文后，进入FIN_WAIT_2状态。")]),t._v(" "),a("li",[t._v("服务器开始处理数据，处理完需要断开的数据后，向客户端回复FIN报文后进入LAST_ACK,意思是只需要客户端再重新确认一遍这个断开是正确的后就可以断开链接")]),t._v(" "),a("li",[t._v("客户端回复ACK报文后 经过2MSL后断开链接")]),t._v(" "),a("li",[t._v("服务器收到ACK后立马断开链接")])]),t._v(" "),a("h3",{attrs:{id:"为什么断开过程中的fin与ack两个报文不能合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么断开过程中的fin与ack两个报文不能合并"}},[t._v("#")]),t._v(" 为什么断开过程中的FIN与ACK两个报文不能合并")]),t._v(" "),a("p",[t._v("虽然客户端发出了断开报文，但是还有一部分正在接受的数据没有完成，发出FIN的意思只是不再发送数据，需要等待正在进行传输的TCP链接完成后断开链接")]),t._v(" "),a("h3",{attrs:{id:"为什么time-wait这个时间段需要经过2msl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么time-wait这个时间段需要经过2msl"}},[t._v("#")]),t._v(" 为什么TIME_WAIT这个时间段需要经过2MSL")]),t._v(" "),a("p",[t._v("MSL：指一个报文在网络中传输存在的最长时间，超过这个时间的所有报文都会被抛弃，而一次发送，一次返回一来回中对应的就是2MSL的时间，这个时间是从收到最后一个FIN报文开始计时的，如果再次收到了FIN报文，就证明这个链接并没有正常关闭，就需要重新对TIME_WAIT进行计时。如果这个TIME_WAIT时间段不够长，就会可能收到在网络中延迟的报文，TCP的2MSL机制保证了两个方向上的所有数据包都被丢弃。")]),t._v(" "),a("h3",{attrs:{id:"tcp的保活机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp的保活机制"}},[t._v("#")]),t._v(" TCP的保活机制")]),t._v(" "),a("p",[t._v("用于解决客户端突然发生故障断开链接的情况，这时候服务端就会触发保活机制，会在一个时间段，这个时间段是可以被定义长度的，在Linux中这个字段叫做tcp_keeplive_time，在这段时间中会定时的发出含有少量数据的报文去探测客户端是否存活，如果超出了这个时间就会被定义成死亡链接然后断开。")]),t._v(" "),a("h3",{attrs:{id:"soceket编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#soceket编程"}},[t._v("#")]),t._v(" Soceket编程")]),t._v(" "),a("p",[t._v("具体流程如下：\n"),a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202211011715504.png",alt:"image-20221101171544398"}})]),t._v(" "),a("ul",[a("li",[t._v("服务端和客户端同时初始化socket，我个人感觉服务器的socket初始化应该早于客户端")]),t._v(" "),a("li",[t._v("服务端调用bind进行绑定IP以及端口号")]),t._v(" "),a("li",[t._v("服务端调用listen开始监听某个端口上的信息")]),t._v(" "),a("li",[t._v("服务端调用accpet等待链接（类似于挂起监听）")]),t._v(" "),a("li",[t._v("客户端调用connect向服务器的端口进行链接")]),t._v(" "),a("li",[t._v("链接正常建立后 （也是通过tcp进行链接的），就可以通过read和write方法进行读写")])]),t._v(" "),a("p",[t._v("Ps：服务端在建立完链接后，accept会返回一个用于传输文件的socket链接，所以在这个过程中服务端有两个socket分别用于链接以及传输文件")]),t._v(" "),a("h3",{attrs:{id:"tcp重传机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp重传机制"}},[t._v("#")]),t._v(" TCP重传机制")]),t._v(" "),a("p",[t._v("重传机制的基础是，TCP源于自身是有效链接，在每次信息完全送达的时候，都会收到一个传递成功得的信息")]),t._v(" "),a("h4",{attrs:{id:"_1-超时重传rto"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-超时重传rto"}},[t._v("#")]),t._v(" 1.超时重传RTO")]),t._v(" "),a("p",[t._v("在发送请求的时候设置一个定时器，如果时间内这个请求没有收到对应的回复请求，就意味着这个请求超时了，服务端就会重新发起这个请求。当然这段时间的长度如何定义也是一个比较重要的问题。\n在讨论这个时间问题我们要知道一个基础概念  RTT：指网络请求从一端到另一端所需的时间，通俗来讲是一个包的"),a("strong",[t._v("往返")]),t._v("时间。\n"),a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202211011812076.png",alt:"image-20221101181258018"}})]),t._v(" "),a("p",[t._v("所以这个RTO的时间也应该跟RTT挂钩，而且不能太长或者太短\n太长：重传性能不好，间隔太大，丢失时间长\n太短：重发频率太高会导致队列堵塞\n所以有个约定俗成的规则，RTO 应该略大于 RTT，这样既保证了请求可以正常发出和返回，也不会因为RTO太大导致重传过慢。")]),t._v(" "),a("p",[t._v("这里还牵扯一个问题，就是网络情况会产生波动的有可能每一次对应的RTT时间都会发生变化，所以对应的RTO值应该属于一个动态的区间内，所以如果一旦发生超时重传，这里的RTO就会被设置成上一次的二倍，这样如果长时间的网络波动，就不会短时间内进行多次重发")]),t._v(" "),a("h4",{attrs:{id:"_2快速重传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2快速重传"}},[t._v("#")]),t._v(" 2快速重传")]),t._v(" "),a("p",[t._v("快速重传不是基于时间进行的，快速重传是基于数据进行的，基于的是发送成功后客户端也会对应返回控制位 + 1 的特性。\n"),a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202211011821265.png",alt:"image-20221101182159215"}})]),t._v(" "),a("p",[t._v("如图所示1，2，3，4，5五份数据，2如果正常传输应该返回ACK3的报文，但是ACK2返回了3次，就意味着除了2对应的包外，其余对应的包都正常送达了。这个时候就需要对Seq2进行重传。但是我们是重传2，还是2，3，4，5这几种可能都有。所以他也只是解决了超时重传后期RTO过长的问题")]),t._v(" "),a("h4",{attrs:{id:"_3sack方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3sack方法"}},[t._v("#")]),t._v(" 3SACK方法")]),t._v(" "),a("p",[t._v("这个方法需要接收方在TCP的选项中添加一个SACK字段，这个字段存放了一个缓存的表，记录了哪些数据已经传输完成了，在后续重传的时候只需要根据SACK字段中缺少的包进行重传就可以了")]),t._v(" "),a("h4",{attrs:{id:"_4duplicate-sack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4duplicate-sack"}},[t._v("#")]),t._v(" 4Duplicate SACK")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202211011843004.png",alt:"image-20221101184349961"}})]),t._v(" "),a("h3",{attrs:{id:"tcp的滑动窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp的滑动窗口"}},[t._v("#")]),t._v(" TCP的滑动窗口")]),t._v(" "),a("p",[t._v("滑动窗口，改善的是TCP一对一的问题，如果这个数据没有传输完成，对话没有结束，就不会开启下一个对话，这样的问题就是一旦每一个对话的长度都非常大，就会导致整个网络中间的吞吐量非常低，处理请求的速度很慢。\n而滑动窗口的出现就可以让前者无需确认应答，后者也可以继续发送数据，而滑动窗口的最大值，就是可以发送请求的数量。")]),t._v(" "),a("h4",{attrs:{id:"滑动窗口的大小"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口的大小"}},[t._v("#")]),t._v(" 滑动窗口的大小")]),t._v(" "),a("p",[t._v("TCP报文头部有一个字段就叫做window，这个字段的值就代表了窗口的大小，一般是由接收端告诉发送端自己还剩余多少缓存区可以用来处理更多的请求，发送端就按照这个标准去发送对应里量的请求。\n所以滑动窗口的大小是由"),a("strong",[t._v("接收方的窗口")]),t._v("大小来决定的")]),t._v(" "),a("h3",{attrs:{id:"发送方的窗口大小会影响什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发送方的窗口大小会影响什么"}},[t._v("#")]),t._v(" 发送方的窗口大小会影响什么")]),t._v(" "),a("p",[t._v("当发送方的窗口满了之后就不能够继续发送数据了，发送方的窗口分为四个部分：")]),t._v(" "),a("ul",[a("li",[t._v("#1 已发送而且收到ACK回复也就是发送完成了")]),t._v(" "),a("li",[t._v("#2 已发送但是没有收到ACK回复,也就是可能需要重传的")]),t._v(" "),a("li",[t._v("#3 未发送,但是在接收方承受范围之内的")]),t._v(" "),a("li",[t._v("#4 未发送,也超出了接收方承受范围")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202211011954919.png",alt:"image-20221101195445840"}})]),t._v(" "),a("h3",{attrs:{id:"程序内如何识别这个四个区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序内如何识别这个四个区域"}},[t._v("#")]),t._v(" 程序内如何识别这个四个区域")]),t._v(" "),a("p",[t._v("类似于滑动窗口算法中的快慢指针")])])}),[],!1,null,null,null);a.default=s.exports}}]);