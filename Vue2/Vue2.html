<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>V-bind 绑定元素属性 | Nianchen的小白之路</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/MylearnBlog/favicon.ico">
    <meta name="description" content="Nianchen的小白之路">
    
    <link rel="preload" href="/MylearnBlog/assets/css/0.styles.918ca8c1.css" as="style"><link rel="preload" href="/MylearnBlog/assets/js/app.9f4c150f.js" as="script"><link rel="preload" href="/MylearnBlog/assets/js/2.e001ac39.js" as="script"><link rel="preload" href="/MylearnBlog/assets/js/12.24390e65.js" as="script"><link rel="prefetch" href="/MylearnBlog/assets/js/10.0b4001f9.js"><link rel="prefetch" href="/MylearnBlog/assets/js/11.66b017f9.js"><link rel="prefetch" href="/MylearnBlog/assets/js/13.6f5ef1cf.js"><link rel="prefetch" href="/MylearnBlog/assets/js/14.d6f99464.js"><link rel="prefetch" href="/MylearnBlog/assets/js/15.716399d7.js"><link rel="prefetch" href="/MylearnBlog/assets/js/16.f2b969ea.js"><link rel="prefetch" href="/MylearnBlog/assets/js/17.0c7af914.js"><link rel="prefetch" href="/MylearnBlog/assets/js/18.b0cf4643.js"><link rel="prefetch" href="/MylearnBlog/assets/js/3.8bde8788.js"><link rel="prefetch" href="/MylearnBlog/assets/js/4.0b9edee6.js"><link rel="prefetch" href="/MylearnBlog/assets/js/5.50c2d115.js"><link rel="prefetch" href="/MylearnBlog/assets/js/6.0bea5b90.js"><link rel="prefetch" href="/MylearnBlog/assets/js/7.989f0155.js"><link rel="prefetch" href="/MylearnBlog/assets/js/8.b1536b68.js"><link rel="prefetch" href="/MylearnBlog/assets/js/9.de1043a3.js">
    <link rel="stylesheet" href="/MylearnBlog/assets/css/0.styles.918ca8c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/MylearnBlog/" class="home-link router-link-active"><!----> <span class="site-name">Nianchen的小白之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/MylearnBlog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MyGithub" class="dropdown-title"><span class="title">MyGithub</span> <span class="arrow down"></span></button> <button type="button" aria-label="MyGithub" class="mobile-dropdown-title"><span class="title">MyGithub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Nianchen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/MylearnBlog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MyGithub" class="dropdown-title"><span class="title">MyGithub</span> <span class="arrow down"></span></button> <button type="button" aria-label="MyGithub" class="mobile-dropdown-title"><span class="title">MyGithub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Nianchen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>入门知识系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/MylearnBlog/browser/browser.html" class="sidebar-link">浏览器原理</a></li><li><a href="/MylearnBlog/javascript/Javascript.html" class="sidebar-link">JavaScript入门</a></li><li><a href="/MylearnBlog/ES6入门/ES6.html" class="sidebar-link">ES6入门</a></li><li><a href="/MylearnBlog/深入系列/深入系列.html" class="sidebar-link">JavaScript深入系列</a></li><li><a href="/MylearnBlog/javascript/Javascript中的设计模式.html" class="sidebar-link">JavaScript设计模式</a></li><li><a href="/MylearnBlog/Vue2/Vue2.html" aria-current="page" class="active sidebar-link">Vue2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/MylearnBlog/Vue2/Vue2.html#v-bind-绑定元素属性" class="sidebar-link">V-bind 绑定元素属性</a></li></ul></li><li><a href="/MylearnBlog/Typescript/Typescript.html" class="sidebar-link">Typescript入门</a></li><li><a href="/MylearnBlog/javascript/正则表达式.html" class="sidebar-link">正则表达式</a></li><li><a href="/MylearnBlog/计算机网络入门/计算机网络.html" class="sidebar-link">计算机网络入门</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>一些简单的面试题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/MylearnBlog/一些简单的面试题/面试相关js.html" class="sidebar-link">一些简单的面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>小工具系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/MylearnBlog/小工具系列/如何搭建自己的图床笔记.html" class="sidebar-link">如何在笔记中添加自己的图床</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="v-bind-绑定元素属性"><a href="#v-bind-绑定元素属性" class="header-anchor">#</a> V-bind 绑定元素属性</h2> <p>将后面所指的东西变为表达式后期直接简写成：
一般 标签的属性利用 ：进行绑定js表达式而标签里面的内容利用双向绑定信息绑定信息。而Vue写法中的 date属性 同样支持吃进一步绑定对象信息 用于区分多个对象之间同名属性 的问题 v-model 利用 这个可以实现双向数据绑定 但是 一般只能利永再 表单元素中 因为一般只有表单元素 拥有value属性</p> <p>所以 V-model 针对的就是表单元素的value进行双向绑定</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931154.png" alt="image-20210729162456492"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931325.png" alt="image-20210730132647608"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931060.png" alt="image-20210730132832555"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931867.png" alt=""></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931376.png" alt="image-20210730143653727"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931132.png" alt="image-20210730144750005"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931629.png" alt="image-20210730145647030"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931114.png" alt="image-20210801145611608"></p> <h3 id="vue数据代理"><a href="#vue数据代理" class="header-anchor">#</a> Vue数据代理</h3> <p>利用defineperproty 进行两个对象类型的互相绑定 利用 seteer 和 getter  对第一个对象调用第二个对象的数据的时候 进行相应修改和操作</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931953.png" alt="image-20211004181755120"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931481.png" alt=""></p> <p>通过数据代理 简化了vue框架的代码 使得后期对vue代码更加简洁
当然_date 中的数据 就是真正的数据位置 只不过vm实例对象对他做了一个数据劫持
Vue 中事件的参数 中$event 可以当作事件传入
@click.事件修饰符</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931886.png" alt="image-20211005145605150"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931667.png" alt="image-20211005150637054"></p> <p>键盘事件中简写的别名</p> <h3 id="vue-的计算属性"><a href="#vue-的计算属性" class="header-anchor">#</a> Vue 的计算属性</h3> <p>计算属性在第一次加载页面的时候就进行了一次加载
如果需要对vue实例的某些属性进行一些 复杂操作 可以借助计算属性 的操作 计算属性 类似于上面的数据代理 后 将处理后的数据 作为一个属性添加到vm身上 如果这个操作并不是太复杂的操作 接用插值表达式就可以</p> <p>这个好处在于他内部维护了一个缓存机制如果数据被多次访问直接用数据可以加快访问速度</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931543.png" alt="image-20211005153254301"></p> <p>如果这个计算属性只考虑读取 没考虑修改的时候 可以将get完全简写成一个函数 以此来简化代码量</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931961.png" alt="image-20211005153538762"></p> <h3 id="vue-监视属性-watch"><a href="#vue-监视属性-watch" class="header-anchor">#</a> Vue 监视属性 watch</h3> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931756.png" alt="image-20211005160108147"></p> <p>对于一些经常改变的值 能设置watch 去监视这个值  如果这个值发生改变 就会 返回改变前后的值 后续对其进行进一步操作</p> <p>深度监视：</p> <div class="language- extra-class"><pre class="language-text"><code>deep：true 开启后 如果 监视对象内部某个属性进行改变 那么进而 就能 出发监视事件  默认不开启 监视某些数组 或者 含有多级层次关系的对象 就会发生错误

相同的效果 计算属性和监听属性 好像都能实现 但是计算属性 无法实现异步操作 但是监听属性 可以开启异步任务

;class 动态绑定 class 后期通过vue 函数进行操作class

:style 同样能实现style的动态绑定 对象或者数组写法 但是同属于date 数据 但是总体还是样式对象的写法

v-show=&quot;true&quot; 只要后面的值 是true 就对元素进行显示 但是只是通过调节 display值进行调整

v-if=“true”   直接删了  同样支持 v-else-if  v-else

v-for  动态执行 多用于未定数量的标签添加  类似于 for in 循环 

 eg：  p in person {{p.id}}进行调用 后面跟上:key 对循环生成的元素进行绑定识别属性
</code></pre></div><p>Vue 的数据监测 十分严格 如果不通过正确的办法进行方法调用 那么页面将不会 进一步更新 Vue 自身 有一个数据代理 他为data中的数据都添加了 相应 的 set get 方法 进行代理 如果不调用对应的方法进行修改数据 那么 Vue框架将不会识别</p> <p>Vue自身 提供了set的方法 进行 添加属性 但是这个方法只能作用域 data中的对象数据 而不能针对vm实例进行添加</p> <p>同样 Vue 也没有为数组设置相应的代理 它默认了数组的七个操作 如果 数组调用对应的方法那么 Vue就会认为 数组发生了更新</p> <p>收集表单数据</p> <p>利用 v-model 进行收集数据  有一定的局限 他只能 收集value</p> <p>所以 在大多数 数据后面 都应该 对应 value值 同样 v-mode 也有一些修饰符 对其进行限制修饰</p> <p>过滤器</p> <p>v-text 插入 文本 完全替换 v-html 可以解析 H5语句  就会存在安全隐患 （避免 cookies 泄露）</p> <p>v-clock  这个属性 会在 页面加载完成的时候 直接删除 这个 属性 利用display 可以做到 让某些元素暂时 隐身的效果、</p> <p>v-once 只让 这个元素 加载一次</p> <p>v-pre  跳过这个节点的 编译阶段 Vue 不去解析了 慎重</p> <p>自定义指令 v-XXX</p> <p>Vue 自身提供了 一个对象 用来让你 自己定义指令</p> <p>与计算属性 和监视属性相似 也可以用函数使用函数式代码</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931106.png" alt="image-20211006144404793"></p> <p>以及页面中的元素 并不是 直接在页面显示的 如果设计Vue语句</p> <p>Vue会先进行解析后 再呈现在页面 并不是像原生JS一样 先把所有元素呈现在页面上后 然后在进行一系列操作</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931731.png" alt="image-20211006144743962"></p> <p>this指向window 因为指令操作的是元素  已经将绑定的元素通过参数传递给你了 没必要再调用this了</p> <h3 id="vue的生命周期"><a href="#vue的生命周期" class="header-anchor">#</a> Vue的生命周期</h3> <p>Vue再进一步解析也经历了多个阶段在每个阶段调用的函数不同，比如说 他在处理完后 将真实的Dom元素往页面挂载完之后调用的mounted函数总体 来说 分为</p> <p>1.挂载流程</p> <p>Vm实例创造前 beforecreate 无法访问vm实例数据 方法</p> <p>Vm实例创造 created 可以访问Vm数据</p> <p>beforemount 挂载之前 未经Vue处理的dom节点</p> <p>mounted 经过Vue编译处理后的dom节点</p> <p>2.更新流程</p> <p>beforeupdata 更新之前 此时Vue拿到新数据 但是页面不更新</p> <p>新旧虚拟Dom比较</p> <p>updata 更新 此时页面与数据同步</p> <p>3.销毁流程</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931729.png" alt="image-20211006154001952"></p> <h3 id="vue组件化开发"><a href="#vue组件化开发" class="header-anchor">#</a> Vue组件化开发</h3> <p>类似于模块化开发 把模块都开发后 实现局部功能和代码 然后把 东西一组装 啥都有了</p> <p>分为 单组件开发 和非单组件开发  后者就是组件的套娃 一个里面套娃多个组件</p> <p>组件的使用一般分为三部</p> <p>1.创建组件 意思就是 通过Vue.extend 先去创建一个组件</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131931450.png" alt="image-20211006191605793"></p> <p>当然 组件中的属性按照 Vm实例上的数据写就行，但是注意这里的data属性 原来由于简写 直接写成了对象形式 ，但是在这里要写成函数形式 且具有 “对象”式的返回值  将数据存储在这个对象中 其他写法相差无几</p> <p>你可以简写为一个对像 vue为你执行 Vue.extend</p> <p>2.注册组件</p> <p>既然建立了一个组件那么就可能在相应的地方去使用组件，当然 既然组件同属于Vm实例 那么就应该在Vm实例中注册组件<img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932342.png" alt="image-20211006191833702"></p> <p>利用新的关键字进行注册组件 然后才能在相应的地方使用</p> <p>注意 注册组件的最终名字才是你最后使用组件 的名字 之前创建组件的名字只是一个中专量  当然 写同名最好 可以简写</p> <p>组件命名规则</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932020.png" alt="image-20211125162040076"></p> <p>3使用组件</p> <p>注册完组件以后 相应的要使用组件，但是 既然组件服务于自身所属的那一小片区域 且根据组件化的定义 自身的样式 以及 格式 都应该在组件 自身身上 所以使用 template 属性取声明自身组件的样子</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932097.png" alt="image-20211006192106965"></p> <p>之后 相应页面中的 H5语句 消失 ， 那么既然要使用相应的组件 就离不开 H5最核心的语言 标签语言 利用 <code>&lt;school&gt;&lt;/school&gt;</code>这种组件直接调用 组件</p> <p>这种注册 也被称为 局部组件</p> <p>这种非单文件组件 无法写css</p> <p>组件的底层原理：</p> <p>其实就是 返回了一个对象但是这这种对象和Vm实例对象又不一样 他其实是 组件构造函数的一个对象 虽然两者功能 相似 但底层还是不一样</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932330.png" alt="image-20211006205008143"></p> <h3 id="vue组件自定义事件"><a href="#vue组件自定义事件" class="header-anchor">#</a> Vue组件自定义事件</h3> <p>自定义如果需要接受数据 那么回调函数一定是在本组件内进行回调然后修改相应的值</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932268.png" alt="image-20211015185339859"></p> <h3 id="全局事件总线"><a href="#全局事件总线" class="header-anchor">#</a> 全局事件总线</h3> <p>利用props这种承接父亲方法的模式 进行传输数据比较麻烦 因为每次的方法都需要父亲向下传递，我们更希望这些操作数据的方法本身就在父亲自己身上，且多个组件都能调用的到，需要像声明全局变量一样声明一个全局的，可以被所有组件共同调用的属性。
我们都知道 每一个组件在建立的时候都会有一个vc对象被建立，且所有组件根据原型链表示，在寻找原型的过程中最终都会找到Vue对象身上，所以我们应该将这个可以被访问的属性放在这个上面，就解决了我们需要从不同的组件访问这个东西的问题</p> <p>但是我们又需要这个属性 在本质上可以调用自定义事件的能力，所以我们更能进一步想到，在这里绑定一个Vue上去 也就是 vue上有一个vue 但是后者vue主要是为了实现某些方法而装上取得</p> <p>我们一般称这个属性为 $bus 又称安装全局事件总线</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932891.png" alt="image-20211015182133927"></p> <p>当然这个总线虽然支持所有组件之间数据的互通 但是对于不如说 父传子 直接利用props 子传父 利用自定义事件或者 props 这些当然更快  但是对于多重组件嵌套的时候 由于多重props利用起来十分复杂 就应该使用全局事件总线进行传递</p> <h3 id="消息的订阅与发布"><a href="#消息的订阅与发布" class="header-anchor">#</a> 消息的订阅与发布</h3> <p>订阅消息不可少的是消息名 以及内容  名字用来找到你 然后信息携带内容  这种方法一般需要调用第三法方库去实现 但是一旦你调用了第三方库之后  Vue就不再帮你维护这个this了 所以 应该使用箭头函数去写回调函数来保证this的指向安全</p> <h3 id="vue-的过度与动画"><a href="#vue-的过度与动画" class="header-anchor">#</a> Vue 的过度与动画</h3> <p>Vue的过度 与动画 基于CCS3  也需要使用关键帧定义出来 先后的顺序 只不过</p> <p>他内部 维护了一个过度标签 你只需要 将 需要发生过的的元素放在 标签内 他就能为你 自动处理 某些动画和 过度 且 这些动画与 过度 的名字都由vue定义</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932713.png" alt="image-20211016190953240"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932331.png" alt="image-20211016193502297"></p> <h3 id="利用-vue-cli处理ajax请求跨域问题"><a href="#利用-vue-cli处理ajax请求跨域问题" class="header-anchor">#</a> 利用 Vue-cli处理Ajax请求跨域问题</h3> <p>利用设置代理 进行配置跨域 请求 其实就是另开了一个服务器 利用这个代理转发了一次请求文件 同步了端口信息进一步 让跨域请求得到相应</p> <p>组件开发的第一步一般都是把页面里的的静态组件给拆分出来 然后再进一步 的对每个组件进行细节描述</p> <p><img src="https://i.loli.net/2021/10/17/FVNsLIbuKUDPQSv.png" alt="image-20211017175036874"></p> <p>这四个东西经常用来发送 ajax请求</p> <p>Vue 自身也有一个插件库 可以用来发送Ajax请求  vue-resource 但是这个插件不经常使用 他的使用方法跟axios基本上一样 但是使用了插件以后 vm vc身上都多了$http 用来处理请求</p> <p>由于组件对于使用者而言可能还需要一些临时添加的东西 这个时候开发者就可以在组件内添加一些插槽也就是 slot标签 就跟内存插槽一个意思 在使用的时候 就插到相应的插槽里</p> <h3 id="vuex"><a href="#vuex" class="header-anchor">#</a> Vuex</h3> <p>由于多个组件如果共享数组 使用全局事件总线的话  组件树一旦多起来  就会更加复杂 你需要绑定多个$on 所以 vuex就是为了处理这个共享数据的问题</p> <p>vuex 状态管理 相当于一个公共的仓库  多个组件都能同时访问到 vuex中存放的数据  本身并不是持续存储数据 并不像localstrage cookie可以长时间存储，将两个东西相结合就能写出来 持久化存储的效果了</p> <p>vuex中 有state getter mutations catios modules</p> <p>state 用于存放数组 getter相当于computed 计算属性</p> <p>mutations 相当于methods  但是自身执行的都是同步代码  如果执行异步代码的话  可能倒是视图层和实际数据层不同</p> <p>actions提交mutations的  区别在于 它可以执行异步代码</p> <p>modules 属于所有属性的延申 更好的管理属性  相当于state的组件化开发 在modules中新建多个index.js export出去 然后store引入后 在不同的页面分部引入就行了  但是modules 这种模式 其实是单项数据流 并不像vue本身的双向绑定 虽然你可以通过 state拿到这个数据 但是如果 直接在组件内对 state修改是不被允许的可以通过一个取巧的方法 比如说在mutations中设置一个方法去修改 其实就是自己写了个setter方法</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932745.png" alt="image-20220308200054989"></p> <p>简便写法</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932887.png" alt="image-20220308195441980"></p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932140.png" alt="image-20211018091841888"></p> <p>核心思想就是共享 就是如果这个数据需要多个地方共享 就需要这个东西</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932354.png" alt="image-20211021101336939"></p> <p>多组件共享数据  找时间test一下</p> <p>1.首先既然需要用到vuex 就必须安装和引入vuex 然后使用 也就是 Vue.use(vuex)</p> <p>2.如果 共享的组件比较少 我们可以 只在 store里面声明 state 去记录共享数据  但是一旦 组件太多 务必会导致 state里面数据繁多  所以我们可以选择模块化开发 每一个模块拥有自己的state、mutation、action、 getters 让代码更清晰</p> <p>3.然后就是用具体的计算属性进行返回 state里面的 数据 当然也有简写形式</p> <p>3.之后就是 使用state里面的数据</p> <h3 id="vue-router"><a href="#vue-router" class="header-anchor">#</a> Vue-router</h3> <p>SPA页面的主要应用 也就是在同一域名下 不引起新页面的打开 能让他 在一个页面多次跳转到不同的展示效果 这里就借助了  vue-router  他是专门来处理的Spa的 相应的数据 都需要使用Ajax请求获取 *-/
前端路由 就是由不同的事件触发不同的 组件效果</p> <p>路由自身也是 vue的一个插件 也需要 npm i vue-router安装 安装完后 也需要使用 一般定会在 router文件夹下的index.js文件 就如同 vuex的设计一样 然后再 这里面 对一些需要的东西进行配置 配置完以后 就可以 正常使用了</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932681.png" alt="image-20211019193716049"></p> <p>路由组件你可以写出来很多但是路由器只有那么一个 由一个路由器给你调整多个组件的作用</p> <p>路由是可以嵌套的 在日常SPA页面里 如果存在多个这种 结构 往往需要将 路由嵌套</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932231.png" alt="image-20211021111434300"></p> <p>第一级路由需要 /
后面二级路由 不需要 /  但是需要再 to 后面写清楚 完整地址</p> <p>路由是可以传参数的</p> <p>1.比较简单的query参数 通过 地址后面？ 之后的数据进行传递参数 然后 组件当然可以通过$router.query.???? 把对应的参数取出来</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932538.png" alt="image-20211027185227336"></p> <p>这是比较麻烦的参数写法</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131932907.png" alt="image-20211027185414837"></p> <p>这是相对简单的对象写法 这两种都是 常规的query传参 类型</p> <p>2.params传参数</p> <p>params参数  必须先在路由里面声明好 你需要传递什么参数 然后也是通过地址 ///传递 但是因为你设置了路由所以 他只会把相应的路径解算称路由 剩余的都是参数</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131933152.png" alt="image-20211027190235021"></p> <p>3.在路由里面配置 props参数</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131933106.png" alt="image-20211021153928899"></p> <p>路由的 link - router 标签里的 replace 属性主要决定了 浏览器本地历史里那个 返回键能不能正常使用 因为历史记录本身就是一个栈  正常就是压栈出栈操作 但是一旦你使用这个属性 它就变成了 替换</p> <p>我们都清楚 在使用路由的时候多个组件来回切换的时候 上一个组件实际上 是被销毁了 例如一个输入框 如果我们需要在来回切换的时候保留 其中的信息我们就需要这个  缓存路由</p> <p><img src="https://i.loli.net/2021/10/22/boy7p1jIfJWwgBM.png" alt="image-20211022100646914"></p> <p>其中的参数 也是最重要的 是组件名  告诉浏览器应该保存的是哪一个组件</p> <p>路由守卫 顾名思义 就跟眼石的作用是一样的  当你不设置路由守卫的时候 所有人都能进行 路由的切换 但是 有些页面他需要特定的权限 去看 所以 就需要路由守卫 在跳转路由之前对一些固定条件做一下判断 来确保进行一次正确的路由</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131933650.png" alt="image-20211023155057533"></p> <p>一般使用的 都是前置路由守卫 因为这个时候 其实 路由还没有真正的触发 而且 他里面自带两个非常详细的参数 to from 也就是 你从哪里路由 要往那里去  然后 next就是放行的 意思 你可以 拿到这两个 路径 然后 做一些简单的if判断 之后放行</p> <p>mete{}  可以通过这个mete 更换浏览器的标题</p> <p>！！！但是不管是 前置路由守卫 还是后置守卫 都是对于全局的守卫</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131933136.png" alt="image-20211023155623180"></p> <p>既然已经有全局路由守卫 那么理所当然 就应该有独享的 路由守卫 进行某一个组件的路由控制</p> <p>组件路由守卫 大多数时间 你都不需要对所有组件进行 路由判断</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131933250.png" alt="image-20211023160512118"></p> <p>这是针对某些 特定组件自身的属性 所以不需要对多个路由进行判断了</p> <p><img src="https://cdn.jsdelivr.net/gh/Nianchen/LearnImg/202210131933344.png" alt="image-20211023163129962"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/MylearnBlog/javascript/Javascript中的设计模式.html" class="prev">
        JavaScript设计模式
      </a></span> <span class="next"><a href="/MylearnBlog/Typescript/Typescript.html">
        Typescript入门
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/MylearnBlog/assets/js/app.9f4c150f.js" defer></script><script src="/MylearnBlog/assets/js/2.e001ac39.js" defer></script><script src="/MylearnBlog/assets/js/12.24390e65.js" defer></script>
  </body>
</html>
