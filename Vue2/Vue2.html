<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Nianchen的小白之路</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Nianchen的小白之路">
    
    <link rel="preload" href="/assets/css/0.styles.d6ad21ed.css" as="style"><link rel="preload" href="/assets/js/app.2c39dc21.js" as="script"><link rel="preload" href="/assets/js/3.6bbfb9d2.js" as="script"><link rel="preload" href="/assets/js/2.def91f37.js" as="script"><link rel="prefetch" href="/assets/js/10.0090d9b4.js"><link rel="prefetch" href="/assets/js/11.4e550b25.js"><link rel="prefetch" href="/assets/js/4.057be6df.js"><link rel="prefetch" href="/assets/js/5.0af0ee23.js"><link rel="prefetch" href="/assets/js/6.9a6d87ee.js"><link rel="prefetch" href="/assets/js/7.5ee58d3a.js"><link rel="prefetch" href="/assets/js/8.47e8033e.js"><link rel="prefetch" href="/assets/js/9.b12f6ac2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d6ad21ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Nianchen的小白之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MyGithub" class="dropdown-title"><span class="title">MyGithub</span> <span class="arrow down"></span></button> <button type="button" aria-label="MyGithub" class="mobile-dropdown-title"><span class="title">MyGithub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Nianchen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MyGithub" class="dropdown-title"><span class="title">MyGithub</span> <span class="arrow down"></span></button> <button type="button" aria-label="MyGithub" class="mobile-dropdown-title"><span class="title">MyGithub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Nianchen" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/browser/browser.html" class="sidebar-link">浏览器原理</a></li><li><a href="/javascript/Javascript.html" class="sidebar-link">JavaScript入门</a></li><li><a href="/Vue2/Vue2.html" aria-current="page" class="active sidebar-link">Vue2入门</a></li><li><a href="/javascript/正则表达式.html" class="sidebar-link">正则表达式</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><img src="/assets/img/oDwLTeUpzOVckiy.8af15fd3.png" alt="image-20210729162456492"></p> <p><img src="/assets/img/Jumy6t75WCqil1B.8eb735a8.png" alt="image-20210730132647608"></p> <p><img src="/assets/img/image-20211005144415234.8c3b9d0b.png" alt=""></p> <p><img src="/assets/img/TZoubcWSO4qKwAv.99e9d3af.png" alt="image-20210730143653727"></p> <p><img src="/assets/img/image-20210730144750005.662bfd63.png" alt="image-20210730144750005"></p> <p><img src="/assets/img/image-20210730145647030-16640991739544.9ed20133.png" alt="image-20210730145647030"></p> <p>V-bind 绑定元素属性  将后面所指的东西变为表达式</p> <p>后期直接简写成：</p> <p>一般 标签的属性利用 ：进行绑定js表达式而标签里面的内容利用双向绑定信息绑定信息。</p> <p>而Vue写法中的 date属性 同样支持吃进一步绑定对象信息 用于区分多个对象之间同名属性 的问题</p> <p>v-model 利用 这个可以实现双向数据绑定 但是 一般只能利永再 表单元素中 因为一般只有表单元素 拥有value属性</p> <p>所以 V-model 针对的就是表单元素的value进行双向绑定</p> <p>MVVM</p> <p>架构模式</p> <p>数据代理：</p> <p>利用defineperproty 进行两个对象类型的互相绑定 利用 seteer 和 getter  对第一个对象调用第二个对象的数据的时候 进行相应修改和操作</p> <p><img src="/assets/img/image-20211004181755120.289b5591.png" alt="image-20211004181755120"></p> <p><img src="/assets/img/N8Md7RiJhsvKfaX.8c3b9d0b.png" alt=""></p> <p>通过数据代理 简化了vue框架的代码 使得后期对vue代码更加简洁</p> <p>当然_date 中的数据 就是真正的数据位置 只不过vm实例对象对他做了一个数据劫持</p> <p>Vue 中事件的参数 中$event 可以当作事件传入</p> <p>@click.事件修饰符</p> <p><img src="/assets/img/tITnJ5PBeNVvmi3.f99797cd.png" alt="image-20211005145605150"></p> <p>键盘事件中简写的别名</p> <p>Vue 的计算属性</p> <p>计算属性在第一次加载页面的时候就进行了一次加载</p> <p>如果需要对vue实例的某些属性进行一些 复杂操作 可以借助计算属性 的操作 计算属性 类似于上面的数据代理 后 将处理后的数据 作为一个属性添加到vm身上 如果这个操作并不是太复杂的操作 接用插值表达式就可以</p> <p>这个好处在于   他内部维护了一个缓存机制如果数据被多次访问 接用数据可以加快 访问速度</p> <p><img src="/assets/img/VFRhCQtOuWi2T3Z.48439335.png" alt="image-20211005153254301"></p> <p>如果这个计算属性只考虑读取 没考虑修改的时候 可以将get完全简写成一个函数 以此来简化代码量</p> <p><img src="/assets/img/image-20211005153538762.1a5b7bb4.png" alt="image-20211005153538762"></p> <p>Vue 监视属性 watch</p> <p><img src="/assets/img/image-20211005160108147.2aca5780.png" alt="image-20211005160108147"></p> <p>对于一些经常改变的值 能设置watch 去监视这个值  如果这个值发生改变 就会 返回改变前后的值 后续对其进行进一步操作</p> <p>深度监视：</p> <p>deep：true 开启后 如果 监视对象内部某个属性进行改变 那么进而 就能 出发监视事件  默认不开启 监视某些数组 或者 含有多级层次关系的对象 就会发生错误</p> <p>相同的效果 计算属性和监听属性 好像都能实现 但是计算属性 无法实现异步操作 但是监听属性 可以开启异步任务</p> <p>;class 动态绑定 class 后期通过vue 函数进行操作class</p> <p>:style 同样能实现style的动态绑定 对象或者数组写法 但是同属于date 数据 但是总体还是样式对象的写法</p> <p>v-show=&quot;true&quot; 只要后面的值 是true 就对元素进行显示 但是只是通过调节 display值进行调整</p> <p>v-if=“true”   直接删了  同样支持 v-else-if  v-else</p> <p>v-for  动态执行 多用于未定数量的标签添加  类似于 for in 循环</p> <div class="language- extra-class"><pre class="language-text"><code> eg：  p in person {{p.id}}
</code></pre></div><p>进行调用 后面跟上:key 对循环生成的元素进行绑定识别属性</p> <p>key的原理</p> <p>Vue内部维护的有一个 虚拟Dom对比算法 再进行更新页面的时候 会将新产生的虚拟Dom于原来的虚拟Dom进行对比 将两次不同Dom的地方进行替换 将相同的地方保持不变 进一步在生成真实Dom的时候 减少浏览器渲染负荷  但是如果一旦在 使用key不当的情况下 虚拟Dom 可以误认为 两个不同的 标签 是一个标签 进行替换操作 而不是重新生成 导致 进一步的错误 所以 在 代码中key的存在 尽量保持唯一性 而且 和标签中的 属性 最好一致且唯一</p> <p><img src="/assets/img/lKbAcVpkLwmtEvD.9f080b62.png" alt="image-20211005165958901"></p> <p>Vue 的数据监测 十分严格 如果不通过正确的办法进行方法调用 那么页面将不会 进一步更新 Vue 自身 有一个数据代理 他为data中的数据都添加了 相应 的 set get 方法 进行代理 如果不调用对应的方法进行修改数据 那么 Vue框架将不会识别</p> <p>Vue自身 提供了set的方法 进行 添加属性 但是这个方法只能作用域 data中的对象数据 而不能针对vm实例进行添加</p> <p>同样 Vue 也没有为数组设置相应的代理 它默认了数组的七个操作 如果 数组调用对应的方法那么 Vue就会认为 数组发生了更新</p> <p>收集表单数据</p> <p>利用 v-model 进行收集数据  有一定的局限 他只能 收集value</p> <p>所以 在大多数 数据后面 都应该 对应 value值 同样 v-mode 也有一些修饰符 对其进行限制修饰</p> <p>过滤器</p> <p>v-text 插入 文本 完全替换 v-html 可以解析 H5语句  就会存在安全隐患 （避免 cookies 泄露）</p> <p>v-clock  这个属性 会在 页面加载完成的时候 直接删除 这个 属性 利用display 可以做到 让某些元素暂时 隐身的效果、</p> <p>v-once 只让 这个元素 加载一次</p> <p>v-pre  跳过这个节点的 编译阶段 Vue 不去解析了 慎重</p> <p>自定义指令 v-XXX</p> <p>Vue 自身提供了 一个对象 用来让你 自己定义指令</p> <p>与计算属性 和监视属性相似 也可以用函数使用函数式代码</p> <p><img src="/assets/img/image-20211006144404793.96961751.png" alt="image-20211006144404793"></p> <p>以及页面中的元素 并不是 直接在页面显示的 如果设计Vue语句</p> <p>Vue会先进行解析后 再呈现在页面 并不是像原生JS一样 先把所有元素呈现在页面上后 然后在进行一系列操作</p> <p><img src="C:%5CUsers%5CLenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211006144743962.png" alt="image-20211006144743962"></p> <p>this指向window 因为指令操作的是元素  已经将绑定的元素通过参数传递给你了 没必要再调用this了</p> <p>Vue的生命周期</p> <p>Vue再进一步解析也经历了多个阶段在每个阶段调用的函数不同，比如说 他在处理完后 将真实的Dom元素往页面挂载完之后调用的mounted函数</p> <p>总体 来说 分为</p> <p>1.挂载流程</p> <p>Vm实例创造前 beforecreate 无法访问vm实例数据 方法</p> <p>Vm实例创造 created 可以访问Vm数据</p> <p>beforemount 挂载之前 未经Vue处理的dom节点</p> <p>mounted 经过Vue编译处理后的dom节点</p> <p>2.更新流程</p> <p>beforeupdata 更新之前 此时Vue拿到新数据 但是页面不更新</p> <p>新旧虚拟Dom比较</p> <p>updata 更新 此时页面与数据同步</p> <p>3.销毁流程</p> <p><img src="/assets/img/dNWerqlx5HckJVg.0697885a.png" alt="image-20211006154001952"></p> <p>组件化开发</p> <p>类似于模块化开发 把模块都开发后 实现局部功能和代码 然后把 东西一组装 啥都有了</p> <p>分为 单组件开发 和非单组件开发  后者就是组件的套娃 一个里面套娃多个组件</p> <p>组件的使用一般分为三部</p> <p>1.创建组件 意思就是 通过Vue.extend 先去创建一个组件</p> <p><img src="/assets/img/image-20211006191605793.d3bd9327.png" alt="image-20211006191605793"></p> <p>当然 组件中的属性按照 Vm实例上的数据写就行，但是注意这里的data属性 原来由于简写 直接写成了对象形式 ，但是在这里要写成函数形式 且具有 “对象”式的返回值  将数据存储在这个对象中 其他写法相差无几</p> <p>你可以简写为一个对像 vue为你执行 Vue.extend</p> <p>2.注册组件</p> <p>既然建立了一个组件那么就可能在相应的地方去使用组件，当然 既然组件同属于Vm实例 那么就应该在Vm实例中注册组件<img src="/assets/img/3Wclup5GVx1Mqdn.0d0abdd4.png" alt="image-20211006191833702"></p> <p>利用新的关键字进行注册组件 然后才能在相应的地方使用</p> <p>注意 注册组件的最终名字才是你最后使用组件 的名字 之前创建组件的名字只是一个中专量  当然 写同名最好 可以简写</p> <p>组件命名规则</p> <p><img src="/assets/img/5sN1dE2xmReGvfU.ed4087e1.png" alt="image-20211125162040076"></p> <p>3使用组件</p> <p>注册完组件以后 相应的要使用组件，但是 既然组件服务于自身所属的那一小片区域 且根据组件化的定义 自身的样式 以及 格式 都应该在组件 自身身上 所以使用 template 属性取声明自身组件的样子</p> <p>之后 相应页面中的 H5语句 消失 ， 那么既然要使用相应的组件 就离不开 H5最核心的语言 标签语言 利用 <school></school>这种组件直接调用 组件</p> <p>这种注册 也被称为 局部组件</p> <p>这种非单文件组件 无法写css</p> <p>组件的底层原理：</p> <p>其实就是 返回了一个对象但是这这种对象和Vm实例对象又不一样 他其实是 组件构造函数的一个对象 虽然两者功能 相似 但底层还是不一样</p> <p><img src="/assets/img/qy9GgkwKJBHSePX.217a3e5e.png" alt="image-20211006205008143"></p> <p>原型问题</p> <p>文件组件 详情见自己写的代码</p> <p>组件自定义事件</p> <p>自定义如果需要接受数据 那么回调函数一定是在本组件内进行回调然后修改相应的值</p> <p><img src="/assets/img/jGCVJL48n1zAXe2.3f76ae93.png" alt="image-20211015185339859"></p> <p>全局事件总线</p> <p>利用props这种承接父亲方法的模式 进行传输数据比较麻烦 因为每次的方法都需要父亲向下传递，我们更希望这些操作数据的方法本身就在父亲自己身上，且多个组件都能调用的到，需要像声明全局变量一样声明一个全局的，可以被所有组件共同调用的属性。
我们都知道 每一个组件在建立的时候都会有一个vc对象被建立，且所有组件根据原型链表示，在寻找原型的过程中最终都会找到Vue对象身上，所以我们应该将这个可以被访问的属性放在这个上面，就解决了我们需要从不同的组件访问这个东西的问题</p> <p>但是我们又需要这个属性 在本质上可以调用自定义事件的能力，所以我们更能进一步想到，在这里绑定一个Vue上去 也就是 vue上有一个vue 但是后者vue主要是为了实现某些方法而装上取得</p> <p>我们一般称这个属性为 $bus 又称安装全局事件总线</p> <p><img src="/assets/img/image-20211015182133927.88e99b76.png" alt="image-20211015182133927"></p> <p>当然这个总线虽然支持所有组件之间数据的互通 但是对于不如说 父传子 直接利用props 子传父 利用自定义事件或者 props 这些当然更快  但是对于多重组件嵌套的时候 由于多重props利用起来十分复杂 就应该使用全局事件总线进行传递</p> <p>消息的订阅与发布</p> <p>订阅消息不可少的是消息名 以及内容  名字用来找到你 然后信息携带内容  这种方法一般需要调用第三法方库去实现 但是一旦你调用了第三方库之后  Vue就不再帮你维护这个this了 所以 应该使用箭头函数去写回调函数来保证this的指向安全</p> <p>Vue 的过度与动画</p> <p>Vue的过度 与动画 基于CCS3  也需要使用关键帧定义出来 先后的顺序 只不过</p> <p>他内部 维护了一个过度标签 你只需要 将 需要发生过的的元素放在 标签内 他就能为你 自动处理 某些动画和 过度 且 这些动画与 过度 的名字都由vue定义</p> <p><img src="/assets/img/lYyxfW7izpgQZ2q.556fb94d.png" alt="image-20211016193502297"></p> <p>利用 cli处理Ajax请求跨域问题</p> <p>利用设置代理 进行配置跨域 请求 其实就是另开了一个服务器 利用这个代理转发了一次请求文件 同步了端口信息进一步 让跨域请求得到相应</p> <p>组件开发的第一步一般都是把页面里的的静态组件给拆分出来 然后再进一步 的对每个组件进行细节描述</p> <p><img src="/assets/img/FVNsLIbuKUDPQSv.3b0b8e08.png" alt="image-20211017175036874"></p> <p>这四个东西经常用来发送 ajax请求</p> <p>Vue 自身也有一个插件库 可以用来发送Ajax请求  vue-resource 但是这个插件不经常使用 他的使用方法跟axios基本上一样 但是使用了插件以后 vm vc身上都多了$http 用来处理请求</p> <p>由于组件对于使用者而言可能还需要一些临时添加的东西 这个时候开发者就可以在组件内添加一些插槽也就是 slot标签 就跟内存插槽一个意思 在使用的时候 就插到相应的插槽里</p> <p>Vuex</p> <p>由于多个组件如果共享数组 使用全局事件总线的话  组件树一旦多起来  就会更加复杂 你需要绑定多个$on 所以 vuex就是为了处理这个共享数据的问题</p> <p><img src="/assets/img/lJdZMcsBIx2TAOa.a35eef95.png" alt="image-20211018091841888"></p> <p>核心思想就是共享 就是如果这个数据需要多个地方共享 就需要这个东西</p> <p><img src="/assets/img/image-20211021101336939.9b7091a5.png" alt="image-20211021101336939"></p> <p>多组件共享数据  找时间test一下</p> <p>1.首先既然需要用到vuex 就必须安装和引入vuex 然后使用 也就是 Vue.use(vuex)</p> <p>2.如果 共享的组件比较少 我们可以 只在 store里面声明 state 去记录共享数据  但是一旦 组件太多 务必会导致 state里面数据繁多  所以我们可以选择模块化开发 每一个模块拥有自己的state、mutation、action、 getters 让代码更清晰</p> <p>3.然后就是用具体的计算属性进行返回 state里面的 数据 当然也有简写形式</p> <p>3.之后就是 使用state里面的数据</p> <p>路由：</p> <p>SPA页面的主要应用 也就是在同一域名下 不引起新页面的打开 能让他 在一个页面多次跳转到不同的展示效果 这里就借助了  vue-router  他是专门来处理的Spa的 相应的数据 都需要使用Ajax请求获取 *-/
前端路由 就是由不同的事件触发不同的 组件效果</p> <p>路由自身也是 vue的一个插件 也需要 npm i vue-router安装 安装完后 也需要使用 一般定会在 router文件夹下的index.js文件 就如同 vuex的设计一样 然后再 这里面 对一些需要的东西进行配置 配置完以后 就可以 正常使用了</p> <p><img src="/assets/img/image-20211019193716049.bb232cb9.png" alt="image-20211019193716049"></p> <p>路由组件你可以写出来很多但是路由器只有那么一个 由一个路由器给你调整多个组件的作用</p> <p>路由是可以嵌套的 在日常SPA页面里 如果存在多个这种 结构 往往需要将 路由嵌套</p> <p><img src="/assets/img/QUbCV7L19AO5XvN.02a99d70.png" alt="image-20211021111434300"></p> <p>第一级路由需要 /
后面二级路由 不需要 /  但是需要再 to 后面写清楚 完整地址</p> <p>路由是可以传参数的</p> <p>1.比较简单的query参数 通过 地址后面？ 之后的数据进行传递参数 然后 组件当然可以通过$router.query.???? 把对应的参数取出来</p> <p><img src="/assets/img/image-20211027185227336.2bc0bc17.png" alt="image-20211027185227336"></p> <p>这是比较麻烦的参数写法</p> <p><img src="/assets/img/image-20211027185414837.4acfc7b3.png" alt="image-20211027185414837"></p> <p>这是相对简单的对象写法 这两种都是 常规的query传参 类型</p> <p>2.params传参数</p> <p>params参数  必须先在路由里面声明好 你需要传递什么参数 然后也是通过地址 ///传递 但是因为你设置了路由所以 他只会把相应的路径解算称路由 剩余的都是参数</p> <p><img src="/assets/img/KdHogkLpSVf7BUT.478c3f09.png" alt="image-20211027190235021"></p> <p>3.在路由里面配置 props参数</p> <p><img src="/assets/img/image-20211021153928899.d7da1dd3.png" alt="image-20211021153928899"></p> <p>路由的 link - router 标签里的 replace 属性主要决定了 浏览器本地历史里那个 返回键能不能正常使用 因为历史记录本身就是一个栈  正常就是压栈出栈操作 但是一旦你使用这个属性 它就变成了 替换</p> <p>我们都清楚 在使用路由的时候多个组件来回切换的时候 上一个组件实际上 是被销毁了 例如一个输入框 如果我们需要在来回切换的时候保留 其中的信息我们就需要这个  缓存路由</p> <p><img src="/assets/img/boy7p1jIfJWwgBM.56fd309a.png" alt="image-20211022100646914"></p> <p>其中的参数 也是最重要的 是组件名  告诉浏览器应该保存的是哪一个组件</p> <p>路由守卫 顾名思义 就跟眼石的作用是一样的  当你不设置路由守卫的时候 所有人都能进行 路由的切换 但是 有些页面他需要特定的权限 去看 所以 就需要路由守卫 在跳转路由之前对一些固定条件做一下判断 来确保进行一次正确的路由</p> <p><img src="/assets/img/image-20211023155057533.2925e4ec.png" alt="image-20211023155057533"></p> <p>一般使用的 都是前置路由守卫 因为这个时候 其实 路由还没有真正的触发 而且 他里面自带两个非常详细的参数 to from 也就是 你从哪里路由 要往那里去  然后 next就是放行的 意思 你可以 拿到这两个 路径 然后 做一些简单的if判断 之后放行</p> <p>mete{}  可以通过这个mete 更换浏览器的标题</p> <p>！！！但是不管是 前置路由守卫 还是后置守卫 都是对于全局的守卫</p> <p><img src="/assets/img/image-20211023155623180.046959bb.png" alt="image-20211023155623180"></p> <p>既然已经有全局路由守卫 那么理所当然 就应该有独享的 路由守卫 进行某一个组件的路由控制</p> <p>组件路由守卫 大多数时间 你都不需要对所有组件进行 路由判断</p> <p><img src="/assets/img/2HwK3NxPkqRCihl.67b49d03.png" alt="image-20211023160512118"></p> <p>这是针对某些 特定组件自身的属性 所以不需要对多个路由进行判断了</p> <hr> <p>ES6 模块化标准</p> <p>模块化的过程 最基本的就是导入导出</p> <p>Axios 的请求封装</p> <div class="language-js extra-class"><pre class="language-js"><code>通过对vue axios请求的封装 减少后期维护代码的工作量
而且可以施加拦截器对axios请求进行进一步分析  拦截对错误信息也可以进行进一步提示
基本模板
network<span class="token operator">/</span>request<span class="token punctuation">.</span>js
<span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">baseURL</span><span class="token operator">:</span><span class="token operator">/</span><span class="token comment">/////</span>
        <span class="token literal-property property">timeout</span><span class="token operator">:</span><span class="token operator">/</span><span class="token comment">/////</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    
    instance<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> config
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token parameter">err</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
	<span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">instance</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/javascript/Javascript.html" class="prev">
        JavaScript入门
      </a></span> <span class="next"><a href="/javascript/正则表达式.html">
        正则表达式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2c39dc21.js" defer></script><script src="/assets/js/3.6bbfb9d2.js" defer></script><script src="/assets/js/2.def91f37.js" defer></script>
  </body>
</html>
